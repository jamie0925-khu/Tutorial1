import math
import pygame
import numpy as np

# --- 시뮬레이션 파라미터 ---
r = 0.05   # wheel radius [m]
l = 0.2    # half distance between wheels [m]
dt = 0.02  # time step [s]
steps = 3000  # 충분히 길게
scale = 200   # m -> px (1 m = 200 px)

# --- 창 설정 ---
WIDTH, HEIGHT = 900, 700
BG_COLOR = (20, 22, 26)
PATH_COLOR = (70, 160, 255)
ROBOT_COLOR = (255, 220, 90)
TEXT_COLOR = (200, 210, 220)

# --- 초기 상태 (월드 좌표(m)) ---
x, y, theta = 0.0, 0.0, 0.0
path = [(x, y)]

# --- 바퀴 각속도 -> [v, omega] 변환 행렬 ---
T = r * np.array([
    [0.5,        0.5],
    [1.0/(2*l), -1.0/(2*l)]
])

# --- 바퀴 속도 ---
T_dot = np.array([
    [0.5,        0.5],
    [1.0/(2*l), -1.0/(2*l)]
])

# --- pygame 초기화 ---
pygame.init()
screen = pygame.display.set_mode((WIDTH, HEIGHT))
pygame.display.set_caption("Differential Drive Robot (pygame)")
clock = pygame.time.Clock()
font = pygame.font.SysFont("consolas", 16)

# 화면 중앙을 월드의 (0,0)으로 매핑
def world_to_screen(wx, wy):
    # 월드 y축이 위로 증가하도록, 화면 y축 반전
    sx = WIDTH // 2 + int(wx * scale)
    sy = HEIGHT // 2 - int(wy * scale)
    return sx, sy

def draw_grid(surf, spacing=0.1, color=(50, 50, 60)):
    # spacing: 격자 간격 [m] , color: 선 색상
    # 화면 전체 범위를 월드 좌표로 변환
    # (왼쪽 위, 오른쪽 아래)
    wx_min = -(WIDTH // 2) / scale
    wx_max = (WIDTH // 2) / scale
    wy_min = -(HEIGHT // 2) / scale
    wy_max = (HEIGHT // 2) / scale

    # 세로선 (x 고정)
    x = math.floor(wx_min / spacing) * spacing
    while x <= wx_max:
        x1, y1 = world_to_screen(x, wy_min)
        x2, y2 = world_to_screen(x, wy_max)
        pygame.draw.line(surf, color, (x1, y1), (x2, y2), 1)
        x += spacing

    # 가로선 (y 고정)
    y = math.floor(wy_min / spacing) * spacing
    while y <= wy_max:
        x1, y1 = world_to_screen(wx_min, y)
        x2, y2 = world_to_screen(wx_max, y)
        pygame.draw.line(surf, color, (x1, y1), (x2, y2), 1)
        y += spacing


def draw_robot(surf, x, y, theta, wheel_base=2*l, radius=0.08):
    # 로봇 본체와 진행 방향을 그린다
    cx, cy = world_to_screen(x, y)
    body_radius_px = max(3, int(radius * scale))
    pygame.draw.circle(surf, ROBOT_COLOR, (cx, cy), body_radius_px, width=2)

    # 진행 방향 라인
    head_len = radius * 1.5
    hx = x + head_len * math.cos(theta)
    hy = y + head_len * math.sin(theta)
    hx_px, hy_px = world_to_screen(hx, hy)
    pygame.draw.line(surf, ROBOT_COLOR, (cx, cy), (hx_px, hy_px), 2)

    # 바퀴 위치 표시
    half_base = wheel_base / 2.0
    # 좌/우 바퀴 중심 (차체 중심에서 좌표)
    left_wx = x - half_base * math.sin(theta)
    left_wy = y + half_base * math.cos(theta)
    right_wx = x + half_base * math.sin(theta)
    right_wy = y - half_base * math.cos(theta)
    lwx, lwy = world_to_screen(left_wx, left_wy)
    rwx, rwy = world_to_screen(right_wx, right_wy)
    pygame.draw.circle(surf, (180, 120, 255), (lwx, lwy), 3)
    pygame.draw.circle(surf, (120, 255, 180), (rwx, rwy), 3)

def draw_path(surf, pts, color=PATH_COLOR):
    if len(pts) < 2:
        return
    # 월드 -> 스크린 변환 후 폴리라인
    screen_pts = [world_to_screen(px, py) for (px, py) in pts]
    pygame.draw.lines(surf, color, False, screen_pts, 2)

def draw_hud(surf, v, omega, x, y, theta, fps):
    lines = [
        f"x={x: .3f} m, y={y: .3f} m",
        f"theta={theta: .3f} rad",
        f"v={v: .3f} m/s, omega={omega: .3f} rad/s",
        f"dt={dt: .3f} s, FPS={fps: .1f} (target ~{int(1/dt)})",
        "ESC to quit",
    ]
    x0, y0 = 10, 10
    for i, txt in enumerate(lines):
        img = font.render(txt, True, TEXT_COLOR)
        surf.blit(img, (x0, y0 + i * 18))

def main():
    global x, y, theta

    running = True
    step = 0
    while running:
        # 이벤트 처리
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
        keys = pygame.key.get_pressed()
        if keys[pygame.K_ESCAPE]:
            running = False

         # --- 바퀴 속도 (오른쪽, 왼쪽) ---
        vel_r = 2.0
        vel_l = 2.0

        # --- 바퀴 각속도 (오른쪽, 왼쪽) ---
        phi1_dot = 1.0 + 0.3 * math.sin(step * 0.05)  # 오른쪽
        phi2_dot = 1.0 + 0.3 * math.cos(step * 0.05)  # 왼쪽

        v, omega = T_dot @ np.array([vel_r, vel_l])

        # --- 행렬 곱으로 v, omega 계산 ---
        #v, omega = T @ np.array([phi1_dot, phi2_dot])

        # --- 정확 적분 ---
        if abs(omega) < 1e-9:
            x += v * math.cos(theta) * dt
            y += v * math.sin(theta) * dt
            # theta는 동일
        else:
            R = v / omega
            dtheta = omega * dt
            x += R * (math.sin(theta + dtheta) - math.sin(theta))
            y += -R * (math.cos(theta + dtheta) - math.cos(theta))
            theta += dtheta

        # 각도 정규화
        theta = (theta + math.pi) % (2 * math.pi) - math.pi

        # 경로 축적
        path.append((x, y))
        # 너무 길어지면 성능 위해 제한
        if len(path) > 5000:
            del path[:1000]

        # --- 렌더링 ---
        screen.fill(BG_COLOR)
        draw_grid(screen, spacing=0.1)
        draw_path(screen, path)
        draw_robot(screen, x, y, theta)
        fps = clock.get_fps()
        draw_hud(screen, v, omega, x, y, theta, fps)

        pygame.display.flip()

        # dt에 맞추어 프레임 고정
        clock.tick(int(1.0 / dt))
        step += 1

    pygame.quit()

if __name__ == "__main__":
    main()
